package com.example.testapp.ui;

import android.view.LayoutInflater;
import android.view.ViewGroup;

import com.example.testapp.R;
import com.example.testapp.databinding.SchoolSummaryTextboxBinding;
import com.example.testapp.db.entity.SchoolEntity;

import java.util.List;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.databinding.DataBindingUtil;
import androidx.recyclerview.widget.DiffUtil;
import androidx.recyclerview.widget.RecyclerView;

/**
 * NOTE: This does not use the Adapter pattern used in softwawre engineering. Do not confuse the two concepts.
 *
 * Schools adapter, a subclass of RecyclerView's Adapter class. It is used to map each school in the list of schools
 * @code mSchoolsList to a RecyclerView card.
 */
public class SchoolsAdapter extends RecyclerView.Adapter<SchoolsAdapter.SchoolViewHolder> {

    List<SchoolEntity> mSchoolsList; // The list of schools to be shown to the user.

    @Nullable
    private final SchoolNameTextboxClickCallback mSchoolClickCallback; // A callback which is to be attached to each card generated by the RecyclerView. Actual callback implemented elsewhere.

    /**
     * Instantiates a new Schools adapter.
     *
     * @param clickCallback the click callback
     */
    public SchoolsAdapter(@Nullable SchoolNameTextboxClickCallback clickCallback) {
        mSchoolClickCallback = clickCallback;
        setHasStableIds(true); // set this so that the RecyclerView knows each card has a fixed id linked to it
        // (hence why the SchoolEntity entity requires an id - each school's summary textbox will have an id associated with it.)
    }

    /**
     * sets mSchoolsList to the most updated value of schoolsList. Called whenever there is a change in the contents of schoolsList.
     * This method is used to generate the number of cards to generate within SchoolListFragment.
     *
     * @param schoolsList the updated list of schools
     */
    public void setSchoolsList(final List<SchoolEntity> schoolsList) {
        if (mSchoolsList == null) {
            mSchoolsList = schoolsList;
            notifyItemRangeInserted(0, schoolsList.size());
        } else {
            DiffUtil.DiffResult result = DiffUtil.calculateDiff(new DiffUtil.Callback() {
                @Override
                public int getOldListSize() {
                    return mSchoolsList.size();
                }

                @Override
                public int getNewListSize() {
                    return schoolsList.size();
                }

                @Override
                public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {
                    return mSchoolsList.get(oldItemPosition).schoolName.equalsIgnoreCase(
                            schoolsList.get(newItemPosition).schoolName);
                }

                @Override
                public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {
                    return areItemsTheSame(oldItemPosition, newItemPosition);
                }

            });
            mSchoolsList = schoolsList;
            result.dispatchUpdatesTo(this); // let the caller know that mSchoolsList has been updated.
        }
    }

    /**
     * The function that links the summary textbox logic with the xml file for its layout.
     * @param parent the parent element where the textbox is to reside in
     * @param viewType what the view is (not used)
     * @return
     */
    @NonNull
    @Override
    public SchoolViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        SchoolSummaryTextboxBinding binding = DataBindingUtil
                .inflate(LayoutInflater.from(parent.getContext()), R.layout.school_summary_textbox,
                        parent, false);
        binding.setCallback(mSchoolClickCallback);
        return new SchoolViewHolder(binding);
    }

    /**
     * Callback method for what happens when a card is 'binded' to (i.e. it comes into the visible screen of the user)
     * @param holder the card's class
     * @param position the position of the card in the entire list of cards.
     */
    @Override
    public void onBindViewHolder(@NonNull SchoolViewHolder holder, int position) {
        holder.binding.setSchoolName(mSchoolsList.get(position).schoolName); // only pick out school name so we don't need to bind every school-related data to the holder.
        holder.binding.executePendingBindings();
    }

    /**
     * Get the number of items in the list of schools.
     * @return count of number of items in list of schools
     */
    @Override
    public int getItemCount() {
        return mSchoolsList == null ? 0 : mSchoolsList.size();
    }

    @Override
    public long getItemId(int position) {
        return mSchoolsList.get(position).getId();
    }

    /**
     * The actual class to contain data for each summary textbox.
     */
    static class SchoolViewHolder extends RecyclerView.ViewHolder {

        /**
         * The variable which binds the card to the data specified in the school_summary_textbox.xml XML file. Delete it and you won't be able to bind data to the card.
         */
        final SchoolSummaryTextboxBinding binding;

        /**
         * Instantiates a new SchoolEntity view holder.
         *
         * @param binding the binding
         */
        public SchoolViewHolder(SchoolSummaryTextboxBinding binding) {
            super(binding.getRoot());
            this.binding = binding;
        }
    }
}
